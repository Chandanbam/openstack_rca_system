name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Deploy to EC2'
        required: false
        default: 'true'

env:
  # AWS Configuration
  EC2_INSTANCE_TYPE: t3.xlarge
  EC2_AMI_ID: ami-0c02fb55956c7d316
  EC2_KEY_NAME: chandankey
  EC2_SECURITY_GROUP_IDS: sg-0897228e510b5e772
  EC2_SUBNET_ID: subnet-0e8159c89a41f2374
  EC2_VOLUME_SIZE: 32
  EC2_VOLUME_TYPE: gp3
  
  # Docker Configuration
  DOCKER_IMAGE_URI: chandantech/openstack-rca-system:latest
  CONTAINER_PORT: 7051
  CONTAINER_NAME: openstack-rca
  
  # Instance Configuration
  INSTANCE_NAME: openstack-rca-instance
  INSTANCE_TAG_NAME: openstack-rca-app
  
  # SSH Configuration
  SSH_USER: ec2-user
  SSH_KEY_PATH: ~/.ssh/chandankey.pem
  
  # Instance Configuration
  EC2_INSTANCE_ID: i-0efeb1d439792eea9

jobs:
  train-and-mlflow:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Train model and log to MLflow
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
        MLFLOW_ARTIFACT_ROOT: ${{ secrets.MLFLOW_ARTIFACT_ROOT }}
        MLFLOW_S3_ENDPOINT_URL: ${{ secrets.MLFLOW_S3_ENDPOINT_URL }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      run: |
        python train_model.py
        python mlflow_manager.py

  test-rca-rag:
    runs-on: ubuntu-latest
    needs: train-and-mlflow
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run RCA tests
      run: |
        python -m pytest tests/test_rca_analyzer.py -v
    
    - name: Run RAG tests
      run: |
        python -m pytest tests/test_rag_evaluation.py -v

  docker-build-push:
    runs-on: ubuntu-latest
    needs: test-rca-rag
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: ${{ env.DOCKER_IMAGE_URI }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-ec2:
    runs-on: ubuntu-latest
    needs: docker-build-push
    if: github.ref == 'refs/heads/main' || github.event.inputs.deploy == 'true'
    steps:
    - uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_DEFAULT_REGION }}
    
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ${{ env.SSH_KEY_PATH }}
        chmod 600 ${{ env.SSH_KEY_PATH }}
        ssh-keyscan -H github.com >> ~/.ssh/known_hosts
    
    - name: Get instance details and SSH
      run: |
        echo "üìã Getting instance details for: ${{ env.EC2_INSTANCE_ID }}"
        
        # Get public IP
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ env.EC2_INSTANCE_ID }}" \
          --query 'Reservations[*].Instances[*].PublicIpAddress' \
          --output text)
        
        echo "üåê Instance Public IP: $PUBLIC_IP"
        echo "public_ip=$PUBLIC_IP" >> $GITHUB_ENV
        
        # Wait for SSH to be available
        echo "‚è≥ Waiting for SSH to be available..."
        sleep 30
        
        # Test SSH connection
        MAX_SSH_RETRIES=10
        SSH_RETRY_COUNT=0
        SSH_AVAILABLE=false
        
        while [ $SSH_RETRY_COUNT -lt $MAX_SSH_RETRIES ] && [ "$SSH_AVAILABLE" = false ]; do
          if ssh -i ${{ env.SSH_KEY_PATH }} -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"$PUBLIC_IP" "echo 'SSH connection successful'" 2>/dev/null; then
            echo "‚úÖ SSH connection established"
            SSH_AVAILABLE=true
            break
          else
            echo "‚ö†Ô∏è SSH not available yet, waiting 10 seconds..."
            sleep 10
            SSH_RETRY_COUNT=$((SSH_RETRY_COUNT + 1))
          fi
        done
        
        if [ "$SSH_AVAILABLE" = false ]; then
          echo "‚ùå SSH connection failed after $MAX_SSH_RETRIES attempts"
          exit 1
        fi
    
    - name: Deploy application to EC2
      run: |
        echo "üöÄ Deploying application to EC2..."
        
        # Stop and remove existing container
        echo "üßπ Cleaning up existing containers..."
        ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true"
        ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true"
        
        # Pull latest Docker image
        echo "üì• Pulling latest Docker image..."
        ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker pull ${{ env.DOCKER_IMAGE_URI }}"
        
        # Run the container with env-file
        echo "üöÄ Starting application container..."
        ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker run -d --env-file /home/ec2-user/.env --name ${{ env.CONTAINER_NAME }} -p ${{ env.CONTAINER_PORT }}:${{ env.CONTAINER_PORT }} ${{ env.DOCKER_IMAGE_URI }}"
        
        # Wait for container to start
        echo "‚è≥ Waiting for container to start..."
        sleep 10
        
        # Check container status
        echo "üìä Checking container status..."
        ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker ps"
    
    - name: Wait for application to be accessible
      run: |
        echo "‚è≥ Waiting for application to be accessible..."
        
        MAX_RETRIES=30
        RETRY_COUNT=0
        APP_ACCESSIBLE=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$APP_ACCESSIBLE" = false ]; do
          echo "Testing application accessibility (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
          
          if curl -f -s "http://${{ env.public_ip }}:${{ env.CONTAINER_PORT }}" > /dev/null 2>&1; then
            echo "‚úÖ Application is accessible!"
            APP_ACCESSIBLE=true
            break
          else
            echo "‚ö†Ô∏è Application not accessible yet, waiting 10 seconds..."
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          fi
        done
        
        if [ "$APP_ACCESSIBLE" = false ]; then
          echo "‚ö†Ô∏è Application may still be starting up after $MAX_RETRIES attempts"
        fi
    
    - name: Generate deployment summary
      run: |
        echo "üìã Generating deployment summary..."
        
        # Get container status
        CONTAINER_STATUS=$(ssh -i ${{ env.SSH_KEY_PATH }} -o StrictHostKeyChecking=no ${{ env.SSH_USER }}@"${{ env.public_ip }}" "docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'")
          
